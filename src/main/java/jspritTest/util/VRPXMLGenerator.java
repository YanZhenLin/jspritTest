package jspritTest.util;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.io.File;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

public class VRPXMLGenerator {
	
	private String fileName;
	private int noServices; //number of services, each service
	private double serviceDuration;
	//each String is a service type and the value points to the number of services of that type
	private Set skills = new HashSet<String>(); 
	private double maxTimeWindow;
	private double minTimeWindow;
	private double maxXCoordinate; //min x default at 0
	private double maxYCoordinate; //min y default at 0
	
	//we'll make up a random figure for sake of creation
	private double probabilityOfReqSkill = .15;
	
	private static DocumentBuilderFactory documentFactory;
	private static DocumentBuilder documentBuilder;
	
	private static TransformerFactory transformerFactory;
	private static Transformer transformer;
	
	private static Random random;
	
	public VRPXMLGenerator() throws ParserConfigurationException, TransformerConfigurationException{
		if(random == null)
			random = new Random();
		
		if(documentFactory == null){
			documentFactory = DocumentBuilderFactory.newInstance();
			documentBuilder = documentFactory.newDocumentBuilder();
		}
		
		if(transformerFactory == null){
			transformerFactory = TransformerFactory.newInstance();
			transformer = transformerFactory.newTransformer();
		}
	}
	
	public static double getRandom(double min, double max){
		return min+random.nextDouble()*(max-min);
	}
	
	
	public void generateXML() throws TransformerException{
		//create the document
		Document document = documentBuilder.newDocument();
		Element problem = createProblem(document); //gets appended inside the callee 
		
		//create the services
		createServices(problem, document);
		
		DOMSource source = new DOMSource(document);
		if(fileName != null ){
			StreamResult result = new StreamResult( new File("input/autoGeneratedServiceXML/"+fileName+".xml") );
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
			transformer.transform(source, result);
		}
	}
	
	/*
	 * <service id="12" type="service">
           <locationId>12</locationId>
           <coord x="71.0" y="23.0"/>
           <capacity-dimensions>
               <dimension index="0">10</dimension>
           </capacity-dimensions>
           <duration>30.0</duration>
           <timeWindows>
               <timeWindow>
                   <start>500.0</start>
                   <end>600.0</end>
               </timeWindow>
           </timeWindows>
           <requiredSkills>spanish</requiredSkills>
       </service>
	 *  
	 */
	public void createServices(Element problem, Document document){
		Element services = createElement(document, "services");
		problem.appendChild(services);
		for(int i = 0; i < noServices; i++){
			Element service = createElement(document, "service");
			services.appendChild(service);
			
			Attr id_attr = createAttribute(document, "id", Integer.toString(i) );
			service.setAttributeNode( id_attr );
			Attr type_attr = createAttribute(document, "type", "service");
			service.setAttributeNode( type_attr );
			
			Element locationId = createElement(document, "locationId");
			locationId.appendChild(document.createTextNode(Integer.toString(i)));
			service.appendChild(locationId);
			
			Element coordinate = createElement(document, "coord");
			//random generator needed here for x y coordinate generation
			double x = (int)getRandom(0, maxXCoordinate);
			double y = (int)getRandom(0, maxYCoordinate);
			Attr x_attr = createAttribute(document, "x", Double.toString(x));
			Attr y_attr = createAttribute(document, "y", Double.toString(y));
			coordinate.setAttributeNode(x_attr);
			coordinate.setAttributeNode(y_attr);
			service.appendChild(coordinate);
			
			/**
			 * <capacity-dimensions>
               <dimension index="0">10</dimension>
           		</capacity-dimensions>
			 **/
			Element capacity_dimension = createElement(document, "capacity-dimensions");
			Element dimension = createElement(document, "dimension");
			Attr attr = createAttribute(document, "index", "0");
			dimension.setAttributeNode(attr);
			dimension.appendChild( document.createTextNode("10") );
			capacity_dimension.appendChild(dimension);
			service.appendChild(capacity_dimension);
			
			//append the service to the
			//<duration>30.0</duration>
			Element duration = createElement(document, "duration");
			duration.appendChild(document.createTextNode("30.0"));
			service.appendChild(duration);
			
			/**
			 * <timeWindows>
               <timeWindow>
                   <start>500.0</start>
                   <end>600.0</end>
               	</timeWindow>
           		</timeWindows>
			 */
			Element timeWindows = createElement(document, "timeWindows");
			Element timeWindow = createElement(document, "timeWindow" );
			Element start = createElement(document, "start");
			Element end = createElement(document, "end");
			double startTime = getRandomStart(minTimeWindow, maxTimeWindow);
			double endTime = getRandomStart(startTime, maxTimeWindow);
			System.out.println("start time:"+startTime+" end time:"+endTime);
			start.appendChild(document.createTextNode(Double.toString(startTime)));
			timeWindow.appendChild(start);
			end.appendChild(document.createTextNode(Double.toString(endTime)));
			timeWindow.appendChild(end);
			timeWindows.appendChild(timeWindow);
			service.appendChild(timeWindows);
			
			//<requiredSkills>spanish</requiredSkills>
			
			String skill = getSkill();
			if(skill != ""){ //comma delimited
				Element requiredSkills = createElement(document, "requiredSkills");
				requiredSkills.appendChild(document.createTextNode(skill));
				service.appendChild(requiredSkills);
			}
		}
	}
	
	//
	private String getSkill(){
		//base on the probability that we've asserted
		boolean needSkills = false;
		//get a random number between 1 to 100, if that number is less or equal to the probable number, we will get a true requirement 
		double random = getRandom(0, 100);
		if(random <= ( probabilityOfReqSkill*100) )
			needSkills = true;
		
		if(needSkills){
			//get the size of the skills map
			int noOfSkills = skills.size();
			//when we cast from double to int, it rounds down naturally
			int index = (int)getRandom(0, noOfSkills);
			String[] skillsArr = new String[skills.size()];
			skills.toArray(skillsArr);
			
			System.out.println("index:"+index );
			if( index >= skillsArr.length-1 ){ //get the last item if our index is out of bounds
				String temp =  skillsArr[ skillsArr.length-1 ];
				System.out.println("temp:"+temp);
				return temp;
			}else // return the indexed item
				return skillsArr[ index ];
		}else
			return "";
	}
	
	//return random 30 minute windows, setup some restrictions
	private double getRandomStart(double min, double max) {
		double result = maxTimeWindow;
		while( result > maxTimeWindow-30 ){ //must be 30 less than the max window
			result = getRandom(min, max);
		}
		if(result < (min+30)){ //if less than 30 more than the min
			result += 30; //add one hour
		}
		int mod = (int)result % 30; //get the minutes remainder, then we subtract
		return ((int)result) - mod;
	}
	

	@Override
	public String toString() {
		return "VRPXMLGenerator [fileName "+ fileName
				+ ", noServices=" + noServices + ", serviceDuration=" + serviceDuration + ", maxTimeWindow="
				+ maxTimeWindow + ", minTimeWindow=" + minTimeWindow + ", maxXCoordinate=" + maxXCoordinate
				+ ", maxYCoordinate=" + maxYCoordinate + "]";
	}

	/*
	 * xmlns="http://www.w3schools.com"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd"
	 * 
	 */
	private Element createProblem(Document document){
		Element problem = document.createElement("Problem");
		problem.setAttributeNode( createAttribute(document, "xmlns", "http://www.w3schools.com"));
		problem.setAttributeNode( createAttribute(document, "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"));
		problem.setAttributeNode( createAttribute(document, "xsi:schemaLocation", "http://www.w3schools.com vrp_xml_schema.xsd" ));
		//set the problem attributes
		document.appendChild(problem);
		return problem;
	}

	private Element createElement(Document document, String tag){
		Element element = document.createElement(tag);
		return element;
	}
	
	private Attr createAttribute(Document document, String tag, String value){
		Attr attr = document.createAttribute(tag);
		attr.setValue(value);
		return attr;
	}
	
	//makes no sense
	public void addSkill(String skill){
		skills.add(skill);
	}

	public String getFileName() {
		return fileName;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}

	public int getNoServices() {
		return noServices;
	}

	public void setNoServices(int noServices) {
		this.noServices = noServices;
	}

	public double getServiceDuration() {
		return serviceDuration;
	}

	public void setServiceDuration(double serviceDuration) {
		this.serviceDuration = serviceDuration;
	}

	public double getMaxTimeWindow() {
		return maxTimeWindow;
	}

	public void setMaxTimeWindow(double maxTimeWindow) {
		this.maxTimeWindow = maxTimeWindow;
	}

	public double getMinTimeWindow() {
		return minTimeWindow;
	}

	public void setMinTimeWindow(double minTimeWindow) {
		this.minTimeWindow = minTimeWindow;
	}

	public double getMaxXCoordinate() {
		return maxXCoordinate;
	}

	public void setMaxXCoordinate(double maxXCoordinate) {
		this.maxXCoordinate = maxXCoordinate;
	}

	public double getMaxYCoordinate() {
		return maxYCoordinate;
	}

	public void setMaxYCoordinate(double maxYCoordinate) {
		this.maxYCoordinate = maxYCoordinate;
	}
	
	
}
